#Custom SSO

OpenUnison is configured to provide SSO for your API server, the Kubernetes Dashboard, and potentially an API server proxy.  There are more components to your cluster then your API server and dashboard though.  Git repos, other dashboards like for Kiali for Istio and Traefik, monitoring systems, and gitops platforms all have their own GUIs with their own identity systems.  OpenUnison can provide you a single source for authentication that you control.  Once OpenUnison has been onboarded to your central identity provider, it can be an identity broker for any and all of these applications.  This section describes how to integrate applications that:

* Use the same group data and trust as your Kubernetes cluster (such as [ArgoCD](https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/openunison/))
* Use OpenID Connect, but need their own identity information
* Use SAML2
* Need a reverse proxy to send identity data and perform authentication for them, such as the Kubernetes Dashboard

## Extending the Kubernetes Trust

<iframe width="560" height="315" src="https://www.youtube.com/embed/Qpak99xMMvs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

In this simplest example, you can extend the existing Kubernetes OpenID Connect identity provider for your cluster.  This is useful when:

1. Your application will re-use your token to communicate with the API server.  Many dashboards do this so that they don't need to know your credentials.
2. Your application needs the same groups as is used by your cluster
3. Your application needs the same attributes, or **claims** as your cluster

Setting this up is very straight forward.  There are two configuration points:

1. OpenUnison - Create a `Trust` custom resource describing the application you wish to allow to authenticate via OpenUnison
2. Your Application - Give your application the configuration it needs to trust OpenUnison.

The `id_token` generated by the Kubernetes identity provider will look like:

```
{
  "iss": "https://k8sou.apps.domain.com/auth/idp/k8sIdp",
  "aud": "kubernetes",
  "exp": 1645623659,
  "jti": "HDJaev3WKncv6Y4da21XNQ",
  "iat": 1645623599,
  "nbf": 1645623479,
  "sub": "mlbadmin1",
  "name": " Boorshtein",
  "groups": [
    "users",
    "admins"
  ],
  "preferred_username": "mlbadminx-49-x",
  "email": "mlbadmin1@nodomain.io"
}
```

The main claims that you'll be concerned with are:

| Claim | Description |
| ----- | ----------- |
| sub   | The user's unique id, this will map to the attribute cnfigured in your helm chart and will depend on your upstream identity provider. |
| name  | This is generally the user's full name |
| groups | This is a list of groups the user is a member of |
| preferred_username | This is the name of the `User` object in the `openunison` namespace that is used to represent this user.  This can also be used to delete the user's session, forcing them to re-authenticate |
| email | The user's email address |

Next, we'll cover both of these configuration points.

### Configuring OpenUnison

Before configuring a `Trust` for OpenUnison for an application, you'll need to know:

| Data | Description | Example |
| ---- | ----------- | ------- |
| Application redirect | This is a URL that OpenUnison will redirect the user's browser to after authentication.  There can be multiple URLs specified.  This is common when an application has both a web component and a CLI component, like ArgoCD.  See your application's documentation. | https://app.domain.com/redirect/ |
| Client Secret | If the application is a web application, there's generally a client secret that you'll need to generate.  This secret should be long, random, and can't be easily guessed.  ***NOTE*** for applications with a cli component, like ArgoCD, you'll generally skip the client secret |
| Will `user_info` be signed? | Some applications require that the data returned from the user_info endpoing be a signed JWT.  Others just want JSON.  Plain JSON is more common |

Once you gather this information, the next step is create a `Secret` for your `client_secret`, if needed.  The easiest way to do this is in the `orchestra-secrets-source` `Secret` you created when deploying OpenUnison.  Once you created this `Secret`, you can create the `Trust`.  The below is an example for GitLab :

```yaml
apiVersion: openunison.tremolo.io/v1
kind: Trust
metadata:
  labels:
    app.kubernetes.io/name: openunison
    app.kubernetes.io/instance: openunison-orchestra
    app.kubernetes.io/component: gitlab-sso
    app.kubernetes.io/part-of: openunison
  name: gitlab
  namespace: openunison
spec:
  accessTokenSkewMillis: 120000
  accessTokenTimeToLive: 60000
  authChainName: login-service
  clientId: gitlab
  clientSecret:
    keyName: gitlab
    secretName: orchestra-secrets-source
  codeLastMileKeyName: lastmile-oidc
  codeTokenSkewMilis: 60000
  publicEndpoint: false
  redirectURI:
  - https://gitlab.mydomain.com/users/auth/openid_connect/callback
  signedUserInfo: false
  verifyRedirect: true
```

The above YAML can be added to the `openunison` namespace and OpenUnison will pick up the changes automatically.  If no secret is needed, skip `spec.clientSecret`.  Below are the details for each configuration option. 

| Option | Desription |
| ------ | ---------- |
| accessTokenSkewMillis | Milliseconds milliseconds added to account for clock skew |
| accessTokenTimeToLive | Time an access token should live in milliseconds |
| authChainName | The authentication chain to use for login, do not change |
| clientId | The client id shared by your application | 
| clientSecret.scretName | If using a client secret, the name of the `Secret` storing the client secret |
| clientSecret.keyName | The key in the `data` section of the `Secret` storing the client secret |
| codeLastMileKeyName | The name of the key used to encrypt the code token, do not change |
| codeTokenSkewMilis | Milliseconds to add to code token lifetime to account for clock skew |
| publicEndpoint | If `true`, a client secret is required.  If `false`, no client secret is needed |
| redirectURI | List of URLs that are authorized for callback.  If a URL is provided by your application that isn't in this list SSO will fail |
| signedUserInfo | if `true`, the userinfo endpoint will return a signed JSON Web Token.  If `false` it will return plain JSON |
| verifyRedirect | If `true`, the redirect URL provided by the client **MUST** be listed in the `redirectURI` section.  Should **ALLWAYS** be `true` if not in a development environment |

Once the `Trust` has been created, the next step is to configure your application.  

### Configuring Your Application

Once OpenUnison has been configured, the next step is to configure your application.  If your application is able to just accept an issuer, use the URL of your identity provider : `https://host.domain.com/auth/idp/k8sIdp` where `host.domain.com` is the host name for your OpenUnison instance.  You'll also suplly your `Trust`'s `clientId`, and if applicable the client secret you created.

If your application can't lookup this information from the OpenID Connect discovry URL provided by OpenUnison, here are the URLs you can supply:

| URL Type | URL |
| -------- | --- |
| issuer | https://host.domain.com/auth/idp/k8sIdp |
| authorization endpoint | https://host.domain.com/auth/idp/k8sIdp/auth |
| token endpoint | https://host.domain.com/auth/idp/k8sIdp/token |
| user info endpoint | https://host.domain.com/auth/idp/k8sIdp/userinfo |

Again, replace `host.domain.com` with the host of your OpenUnison deployment.

Finally you can also [add a badge to the front page of your OpenUnison portal as well](#adding-a-badge-to-the-portal).

## Creating an OpenID Connect Identity Provider

<iframe width="560" height="315" src="https://www.youtube.com/embed/4Vjz7OL5SHI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

There are multiple scenarios where you can't build a trust off of the trust built for your cluster:

* You need different groups or want to limit groups
* You need specific claims
* You need the existing claims to have different names
* You need to perform a just-in-time provisioning action to a trusted application

In these situations, instead of creating a `Trust` object, you'll create an `Application` object that defines a brand new identity provider.  In this example, we'll create an identity provider for ArgoCD that will limit the groups sent to ArgoCD to only groups that start with `argocd-`.  Also, ArgoCD doesn't like groups from LDAP in distinguished name form, so we'll take just the common name element from the group.  Once we're done, a user with the groups:

```
cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com
cn=group2,ou=Groups,DC=domain,DC=com
cn=argocd-users,ou=Groups,DC=domain,DC=com
cn=argocd-admins,ou=Groups,DC=domain,DC=com
```

will only send

```
argocd-user
argocd-admins
```

to ArgoCD.  The first step is to create a custom `JavaScriptMapping` object.  Nearly every configuration in OpenUnison can be customized using some JavaScript.  Here's the mapping for our groups:

```yaml linenums="1"
---
apiVersion: openunison.tremolo.io/v1
kind: JavaScriptMapping
metadata:
  namespace: openunison
  name: argocd-groups
spec:
  javascript: |-
    function doMapping(user,name) {
      Attribute = Java.type("com.tremolosecurity.saml.Attribute");

      // get the current groups from the user
      var groups = user.getAttribs().get("groups").getValues()

      // list of simple group names
      simpleGroups = new Attribute(name);
      

      // convert groups from LDAP DNs from Active Directory to standard group names
      for (var i=0;i<groups.length;i++) {
        var group = groups.get(i);

        // remove everything before the first '=' and after the first comma ','
        // ex cn=my-group,dc=domain,dc=com --> my-group
        var simpleGroupName = group.substring(group.indexOf('=') + 1, group.indexOf(','));

        // we only want to send argocd groups
        if (simpleGroupName.startsWith('argocd-')) {
          simpleGroups.getValues().add(simpleGroupName);
        }
      }



      return simpleGroups;
    }
```

| Line Numbers | Description |
| ------------ | ----------- |
| 1 - 8 | The YAML used to define this mapping |
| 9 | Function definition, every mapping must have a single function that takes two parameters: the user (`com.tremolosecurity.provisioning.core.User`) and the name of the attribute to create (`java.lang.String`).  This function must resturn an object of `com.tremolosecurity.saml.Attribute` |
| 10 | Make the type `com.tremolosecurity.saml.Attribute` accessible as `Attribute` in the javascript.  This can be done for any Java class |
| 13 - 31 | Perform our business logic |
| 35 | Returns our new attribute |

Once the mapping is created, the next step is to define the `Application` object:

```yaml linenums="1"
---
apiVersion: openunison.tremolo.io/v1
kind: Application
metadata:
  labels:
    app.kubernetes.io/component: openunison-applications
    app.kubernetes.io/instance: openunison-orchestra-login-portal
    app.kubernetes.io/name: openunison
    app.kubernetes.io/part-of: openunison
  name: argocd
  namespace: openunison
spec:
  azTimeoutMillis: 3000
  cookieConfig:
    cookiesEnabled: true
    domain: '#[OU_HOST]'
    httpOnly: true
    keyAlias: session-unison
    logoutURI: /logout
    scope: -1
    secure: true
    sessionCookieName: tremolosession
    timeout: 900
  isApp: false
  urls:
  - azRules:
    - constraint: o=Tremolo
      scope: dn
    filterChain: []
    hosts:
    - '#[OU_HOST]'
    idp:
      className: com.tremolosecurity.idp.providers.OpenIDConnectIdP
      mappings:
        map:
        - sourceType: user
          targetAttributeName: sub
          targetAttributeSource: sub
        - sourceType: composite
          targetAttributeName: name
          targetAttributeSource: ${givename} ${sn}
        - sourceType: user
          targetAttributeName: preferred_username
          targetAttributeSource: uid
        - sourceType: user
          targetAttributeName: email
          targetAttributeSource: mail
        - sourceType: custom
          targetAttributeName: groups
          targetAttributeSource: com.tremolosecurity.mapping.JavaScriptMapping|k8s,openunison,argocd-groups
        strict: true
      params:
        jwtSigningKey: unison-saml2-rp-sig
        k8sNameSpace: 'openunison'
        k8sTarget: k8s
        sessionStoreClassName: com.tremolosecurity.oidc.k8s.K8sSessionStore
      trusts:
      - name: 'https://argocd.apps.192-168-2-104.nip.io/'
        params:
          accessTokenSkewMillis: "120000"
          accessTokenTimeToLive: '60000'
          authChainName: login-service
          clientID: argocd-argocdweb
          codeLastMileKeyName: lastmile-oidc
          codeTokenSkewMilis: '60000'
          publicEndpoint: "true"
          redirectURI: 
          - https://argocd.apps.192-168-2-104.nip.io/auth/callback
          - http://localhost:8085/auth/callback
        secretParams:
        - name: clientSecret
          secretName: orchestra-secrets-source
          secretKey: K8S_DB_SECRET
    results:
      auFail: default-login-failure
      azFail: default-login-failure
    uri: /auth/idp/argocd
```

Here's the explination of each part of this configuration:

| Lines | Description |
| ----- | ----------- |
| 1 - 12 | Standard kubernetes metadata |
| 13 | Determines how long authorization decisions should be cached.  Should generally not be changes and should only be as long as it typically takes a single action (such as an API or page load) to complete |
| 14 - 23 | Determines how the user's session cookie should be configured.  This section should generally be left unchanged when working with Kubernetes |
| 24 | This tells OpenUnison this applications is an identity provider, not a reverse proxy |
| 25 | Every `Application` in OpenUnison is made of multiple `url` entries.  Identity providers, like this one, only have one URL definition. |
| 26 - 28 | Each URL can have its own authorization rules (`azRules`).  An authorization rule is made of a `scope` (one of `dn`,`group`,`filter`,`custom`) and a `constraint`, which defines what the rule is.  The combination of `dn` and `o=Tremolo` tells OpenUnison to authorize any user in the internal LDAP virtual directory.  If you wanted to only allow users in the group `cn=argocd-users,ou=Groups,DC=domain,DC=com` you would use `filter` as the `scope` and `(groups=cn=argocd-users,ou=Groups,DC=domain,DC=com)` as the `constraint` because OpenUnison internally represents groups in the Kubernetes integration as attributes instead of seperate objects. Multipls rules may be listed.  If ***ANY*** rule passes, the url is authorized |
| 29 | Customizations can be done here to impect the request and response.  For identity providers, this is generally not needed |
| 30 - 31 | URLs need specific hosts to be associated with.  This is generally left unchanged |
| 32 - 77 | The `idp` section is where you define the details for your identity provider |
| 33 | The `className` should not change |
| 34 - 51 | The `mappings` section defines which claims, or attributes, will be included in the `id_token` provided to your application.  These same claims are provided by the `user_info` endpoint.  OpenUnison makes no distinction between the attributes in the `id_token` vs `user_info` endpoint.  Each claim has three attributes.  The `sourceType` can be a `user`, `composite`, `static`, or `custom`.  When `user`, the claim is pulled straight for the user's object based on the `targetAttributeSource` attribute.  If `static`, the `targetAttributeSource` is taken as is.  If `composite`, the `targetAttributeSource` provides attributes and text from the user.  Finally, `custom` lets you define a custom implmenetation.  For `groups`, the `targetAttributeSource` is `com.tremolosecurity.mapping.JavaScriptMapping|k8s,openunison,argocd-groups`.  The `com.tremolosecurity.mapping.JavaScriptMapping|` generally won't change.  The `k8s` tells OpenUnison which cluster to pull the mapping from.  `openunison` is the namespace and finally `argocd-groups` is the `JavaScriptMapping` defined earlier. Finally, `strict` tells OpenUnison to only include the attributes specifically defined here.  In general this should be `true` |
| 52 - 56 | This section defines parameters for the identity provider and should generally be left unchanged.  |
| 57 -73 | The `trusts` section is where you define which applications will trust this identity provdier.  This has the same options as a `Trust` object. |
| 70 - 73 | Each trust can provide a list of `secretParams` that references external `Secret` objects instead of local configuration. |
| 74 - 76 | The `results` section defines what happens in response to certain events.  Here, in response to the `auFail` and `azFail` events, the user is redirected to an invalid credentials page |
| 77 | The `uri` tells OpenUnison how to access this identity provider.  It will always follow the pattern `/auth/idp/appname`. |

Once your `Application` is deployed, you can test it without any kind of container restart.  Once you're tested, you can also [add a badge to the front page of your OpenUnison portal as well](#adding-a-badge-to-the-portal).

## Creating a SAML2 Identity Provider

## Using a Reverse Proxy Application

## Adding a "Badge" to the Portal

When you login to the Orchestra portal, there are badges for your tokens and for the dashboard.  You can dynamically add a badge for your application too.  Here's an example `PortalUrl` object for ArgoCD:

```
apiVersion: openunison.tremolo.io/v1
kind: PortalUrl
metadata:
  name: argocd
  namespace: openunison
spec:
  label: ArgoCD
  org: B158BD40-0C1B-11E3-8FFD-0800200C9A66
  url: https://argocd.apps.192-168-2-140.nip.io
  icon: iVBORw0KGgoAAAANSUhEUgAAANIAAADwCAYAAAB1/Tp/AAAfQ3pUWHRSYXcgcHJvZ...
  azRules:
  - constraint: o=Tremolo
    scope: dn
```

| Option | Descriptoin |
| ------ | ----------- |
| label  | The label shown on badge in the portal |
| org    | If using orgnaizations to organize badges, the uuid of the org.  If not using organizations, leave as is |
| url    | The URL the badge should send the user to |
| icon   | A base64 encoded icon with a width of 210 pixels and a height of 240 pixels |
| azRules | Who is authorized to see this badge?  See https://portal.apps.tremolo.io/docs/tremolosecurity-docs/1.0.19/openunison/openunison-manual.html#_applications_applications for an explination of the authorization rules |

Once created, the badge will appear in the Orchestra portal!  No need to restart the containers.