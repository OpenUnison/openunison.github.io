#Custom SSO

OpenUnison is configured to provide SSO for your API server, the Kubernetes Dashboard, and potentially an API server proxy.  There are more components to your cluster then your API server and dashboard though.  Git repos, other dashboards like for Kiali for Istio and Traefik, monitoring systems, and gitops platforms all have their own GUIs with their own identity systems.  OpenUnison can provide you a single source for authentication that you control.  Once OpenUnison has been onboarded to your central identity provider, it can be an identity broker for any and all of these applications.  This section describes how to integrate applications that:

* Use the same group data and trust as your Kubernetes cluster (such as [ArgoCD](https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/openunison/))
* Use OpenID Connect, but need their own identity information
* Use SAML2
* Need a reverse proxy to send identity data and perform authentication for them, such as the Kubernetes Dashboard

## Extending the Kubernetes Trust

<iframe width="560" height="315" src="https://www.youtube.com/embed/Qpak99xMMvs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

In this simplest example, you can extend the existing Kubernetes OpenID Connect identity provider for your cluster.  This is useful when:

1. Your application will re-use your token to communicate with the API server.  Many dashboards do this so that they don't need to know your credentials.
2. Your application needs the same groups as is used by your cluster
3. Your application needs the same attributes, or **claims** as your cluster

Setting this up is very straight forward.  There are two configuration points:

1. OpenUnison - Create a `Trust` custom resource describing the application you wish to allow to authenticate via OpenUnison
2. Your Application - Give your application the configuration it needs to trust OpenUnison.

The `id_token` generated by the Kubernetes identity provider will look like:

```json
{
  "iss": "https://k8sou.apps.domain.com/auth/idp/k8sIdp",
  "aud": "kubernetes",
  "exp": 1645623659,
  "jti": "HDJaev3WKncv6Y4da21XNQ",
  "iat": 1645623599,
  "nbf": 1645623479,
  "sub": "mlbadmin1",
  "name": " Boorshtein",
  "groups": [
    "users",
    "admins"
  ],
  "preferred_username": "mlbadminx-49-x",
  "email": "mlbadmin1@nodomain.io"
}
```

The main claims that you'll be concerned with are:

| Claim | Description |
| ----- | ----------- |
| sub   | The user's unique id, this will map to the attribute cnfigured in your helm chart and will depend on your upstream identity provider. |
| name  | This is generally the user's full name |
| groups | This is a list of groups the user is a member of |
| preferred_username | This is the name of the `User` object in the `openunison` namespace that is used to represent this user.  This can also be used to delete the user's session, forcing them to re-authenticate |
| email | The user's email address |

Next, we'll cover both of these configuration points.

### Configuring OpenUnison

Before configuring a `Trust` for OpenUnison for an application, you'll need to know:

| Data | Description | Example |
| ---- | ----------- | ------- |
| Application redirect | This is a URL that OpenUnison will redirect the user's browser to after authentication.  There can be multiple URLs specified.  This is common when an application has both a web component and a CLI component, like ArgoCD.  See your application's documentation. | https://app.domain.com/redirect/ |
| Client Secret | If the application is a web application, there's generally a client secret that you'll need to generate.  This secret should be long, random, and can't be easily guessed.  ***NOTE*** for applications with a cli component, like ArgoCD, you'll generally skip the client secret |
| Will `user_info` be signed? | Some applications require that the data returned from the user_info endpoing be a signed JWT.  Others just want JSON.  Plain JSON is more common |

Once you gather this information, the next step is create a `Secret` for your `client_secret`, if needed.  The easiest way to do this is in the `orchestra-secrets-source` `Secret` you created when deploying OpenUnison.  Once you created this `Secret`, you can create the `Trust`.  The below is an example for GitLab :

```yaml
apiVersion: openunison.tremolo.io/v1
kind: Trust
metadata:
  labels:
    app.kubernetes.io/name: openunison
    app.kubernetes.io/instance: openunison-orchestra
    app.kubernetes.io/component: gitlab-sso
    app.kubernetes.io/part-of: openunison
  name: gitlab
  namespace: openunison
spec:
  accessTokenSkewMillis: 120000
  accessTokenTimeToLive: 60000
  authChainName: login-service
  clientId: gitlab
  clientSecret:
    keyName: gitlab
    secretName: orchestra-secrets-source
  codeLastMileKeyName: lastmile-oidc
  codeTokenSkewMilis: 60000
  publicEndpoint: false
  redirectURI:
  - https://gitlab.mydomain.com/users/auth/openid_connect/callback
  signedUserInfo: false
  verifyRedirect: true
```

The above YAML can be added to the `openunison` namespace and OpenUnison will pick up the changes automatically.  If no secret is needed, skip `spec.clientSecret`.  Below are the details for each configuration option. 

| Option | Desription |
| ------ | ---------- |
| accessTokenSkewMillis | Milliseconds milliseconds added to account for clock skew |
| accessTokenTimeToLive | Time an access token should live in milliseconds |
| authChainName | The authentication chain to use for login, do not change |
| clientId | The client id shared by your application | 
| clientSecret.scretName | If using a client secret, the name of the `Secret` storing the client secret |
| clientSecret.keyName | The key in the `data` section of the `Secret` storing the client secret |
| codeLastMileKeyName | The name of the key used to encrypt the code token, do not change |
| codeTokenSkewMilis | Milliseconds to add to code token lifetime to account for clock skew |
| publicEndpoint | If `true`, a client secret is required.  If `false`, no client secret is needed |
| redirectURI | List of URLs that are authorized for callback.  If a URL is provided by your application that isn't in this list SSO will fail |
| signedUserInfo | if `true`, the userinfo endpoint will return a signed JSON Web Token.  If `false` it will return plain JSON |
| verifyRedirect | If `true`, the redirect URL provided by the client **MUST** be listed in the `redirectURI` section.  Should **ALLWAYS** be `true` if not in a development environment |

Once the `Trust` has been created, the next step is to configure your application.  

### Configuring Your Application

Once OpenUnison has been configured, the next step is to configure your application.  If your application is able to just accept an issuer, use the URL of your identity provider : `https://host.domain.com/auth/idp/k8sIdp` where `host.domain.com` is the host name for your OpenUnison instance.  You'll also suplly your `Trust`'s `clientId`, and if applicable the client secret you created.

If your application can't lookup this information from the OpenID Connect discovry URL provided by OpenUnison, here are the URLs you can supply:

| URL Type | URL |
| -------- | --- |
| issuer | https://host.domain.com/auth/idp/k8sIdp |
| authorization endpoint | https://host.domain.com/auth/idp/k8sIdp/auth |
| token endpoint | https://host.domain.com/auth/idp/k8sIdp/token |
| user info endpoint | https://host.domain.com/auth/idp/k8sIdp/userinfo |

Again, replace `host.domain.com` with the host of your OpenUnison deployment.

Finally you can also [add a badge to the front page of your OpenUnison portal as well](#adding-a-badge-to-the-portal).

## Creating an OpenID Connect Identity Provider

<iframe width="560" height="315" src="https://www.youtube.com/embed/4Vjz7OL5SHI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

There are multiple scenarios where you can't build a trust off of the trust built for your cluster:

* You need different groups or want to limit groups
* You need specific claims
* You need the existing claims to have different names
* You need to perform a just-in-time provisioning action to a trusted application

In these situations, instead of creating a `Trust` object, you'll create an `Application` object that defines a brand new identity provider.  In this example, we'll create an identity provider for ArgoCD that will limit the groups sent to ArgoCD to only groups that start with `argocd-`.  Also, ArgoCD doesn't like groups from LDAP in distinguished name form, so we'll take just the common name element from the group.  Once we're done, a user with the groups:

```
cn=k8s-cluster-admins,ou=Groups,DC=domain,DC=com
cn=group2,ou=Groups,DC=domain,DC=com
cn=argocd-users,ou=Groups,DC=domain,DC=com
cn=argocd-admins,ou=Groups,DC=domain,DC=com
```

will only send

```
argocd-user
argocd-admins
```

to ArgoCD.  The first step is to create a custom `JavaScriptMapping` object.  Nearly every configuration in OpenUnison can be customized using some JavaScript.  Here's the mapping for our groups:

```yaml linenums="1"
---
apiVersion: openunison.tremolo.io/v1
kind: JavaScriptMapping
metadata:
  namespace: openunison
  name: argocd-groups
spec:
  javascript: |-
    function doMapping(user,name) {
      Attribute = Java.type("com.tremolosecurity.saml.Attribute");

      // get the current groups from the user
      var groups = user.getAttribs().get("groups").getValues()

      // list of simple group names
      simpleGroups = new Attribute(name);
      

      // convert groups from LDAP DNs from Active Directory to standard group names
      for (var i=0;i<groups.length;i++) {
        var group = groups.get(i);

        // remove everything before the first '=' and after the first comma ','
        // ex cn=my-group,dc=domain,dc=com --> my-group
        var simpleGroupName = group.substring(group.indexOf('=') + 1, group.indexOf(','));

        // we only want to send argocd groups
        if (simpleGroupName.startsWith('argocd-')) {
          simpleGroups.getValues().add(simpleGroupName);
        }
      }



      return simpleGroups;
    }
```

| Line Numbers | Description |
| ------------ | ----------- |
| 1 - 8 | The YAML used to define this mapping |
| 9 | Function definition, every mapping must have a single function that takes two parameters: the user (`com.tremolosecurity.provisioning.core.User`) and the name of the attribute to create (`java.lang.String`).  This function must resturn an object of `com.tremolosecurity.saml.Attribute` |
| 10 | Make the type `com.tremolosecurity.saml.Attribute` accessible as `Attribute` in the javascript.  This can be done for any Java class |
| 13 - 31 | Perform our business logic |
| 35 | Returns our new attribute |

Once the mapping is created, the next step is to define the `Application` object:

```yaml linenums="1"
---
apiVersion: openunison.tremolo.io/v2
kind: Application
metadata:
  labels:
    app.kubernetes.io/component: openunison-applications
    app.kubernetes.io/instance: openunison-orchestra-login-portal
    app.kubernetes.io/name: openunison
    app.kubernetes.io/part-of: openunison
  name: argocd
  namespace: openunison
spec:
  azTimeoutMillis: 3000
  cookieConfig:
    cookiesEnabled: true
    domain: '#[OU_HOST]'
    httpOnly: true
    keyAlias: session-unison
    logoutURI: /logout
    scope: -1
    secure: true
    sessionCookieName: tremolosession
    timeout: 900
  isApp: false
  urls:
  - azRules:
    - constraint: o=Tremolo
      scope: dn
    filterChain: []
    hosts:
    - '#[OU_HOST]'
    idp:
      className: com.tremolosecurity.idp.providers.OpenIDConnectIdP
      mappings:
        map:
        - sourceType: user
          targetAttributeName: sub
          targetAttributeSource: sub
        - sourceType: composite
          targetAttributeName: name
          targetAttributeSource: ${givename} ${sn}
        - sourceType: user
          targetAttributeName: preferred_username
          targetAttributeSource: uid
        - sourceType: user
          targetAttributeName: email
          targetAttributeSource: mail
        - sourceType: custom
          targetAttributeName: groups
          targetAttributeSource: com.tremolosecurity.mapping.JavaScriptMapping|k8s,openunison,argocd-groups
        strict: true
      params:
        jwtSigningKey: unison-saml2-rp-sig
        k8sNameSpace: 'openunison'
        k8sTarget: k8s
        sessionStoreClassName: com.tremolosecurity.oidc.k8s.K8sSessionStore
      trusts:
      - name: 'https://argocd.apps.192-168-2-104.nip.io/'
        params:
          accessTokenSkewMillis: "120000"
          accessTokenTimeToLive: '60000'
          authChainName: login-service
          clientID: argocd-argocdweb
          codeLastMileKeyName: lastmile-oidc
          codeTokenSkewMilis: '60000'
          publicEndpoint: "true"
          redirectURI: 
          - https://argocd.apps.192-168-2-104.nip.io/auth/callback
          - http://localhost:8085/auth/callback
        secretParams:
        - name: clientSecret
          secretName: orchestra-secrets-source
          secretKey: K8S_DB_SECRET
    results:
      auFail: default-login-failure
      azFail: default-login-failure
    uri: /auth/idp/argocd
```

Here's the explination of each part of this configuration:

| Lines | Description |
| ----- | ----------- |
| 1 - 12 | Standard kubernetes metadata |
| 13 | Determines how long authorization decisions should be cached.  Should generally not be changes and should only be as long as it typically takes a single action (such as an API or page load) to complete |
| 14 - 23 | Determines how the user's session cookie should be configured.  This section should generally be left unchanged when working with Kubernetes |
| 24 | This tells OpenUnison this applications is an identity provider, not a reverse proxy |
| 25 | Every `Application` in OpenUnison is made of multiple `url` entries.  Identity providers, like this one, only have one URL definition. |
| 26 - 28 | Each URL can have its own authorization rules (`azRules`).  An authorization rule is made of a `scope` (one of `dn`,`group`,`filter`,`custom`) and a `constraint`, which defines what the rule is.  The combination of `dn` and `o=Tremolo` tells OpenUnison to authorize any user in the internal LDAP virtual directory.  If you wanted to only allow users in the group `cn=argocd-users,ou=Groups,DC=domain,DC=com` you would use `filter` as the `scope` and `(groups=cn=argocd-users,ou=Groups,DC=domain,DC=com)` as the `constraint` because OpenUnison internally represents groups in the Kubernetes integration as attributes instead of seperate objects. Multipls rules may be listed.  If ***ANY*** rule passes, the url is authorized |
| 29 | Customizations can be done here to impect the request and response.  For identity providers, this is generally not needed |
| 30 - 31 | URLs need specific hosts to be associated with.  This is generally left unchanged |
| 32 - 77 | The `idp` section is where you define the details for your identity provider |
| 33 | The `className` should not change |
| 34 - 51 | The `mappings` section defines which claims, or attributes, will be included in the `id_token` provided to your application.  These same claims are provided by the `user_info` endpoint.  OpenUnison makes no distinction between the attributes in the `id_token` vs `user_info` endpoint.  Each claim has three attributes.  The `sourceType` can be a `user`, `composite`, `static`, or `custom`.  When `user`, the claim is pulled straight for the user's object based on the `targetAttributeSource` attribute.  If `static`, the `targetAttributeSource` is taken as is.  If `composite`, the `targetAttributeSource` provides attributes and text from the user.  Finally, `custom` lets you define a custom implmenetation.  For `groups`, the `targetAttributeSource` is `com.tremolosecurity.mapping.JavaScriptMapping|k8s,openunison,argocd-groups`.  The `com.tremolosecurity.mapping.JavaScriptMapping|` generally won't change.  The `k8s` tells OpenUnison which cluster to pull the mapping from.  `openunison` is the namespace and finally `argocd-groups` is the `JavaScriptMapping` defined earlier. Finally, `strict` tells OpenUnison to only include the attributes specifically defined here.  In general this should be `true` |
| 52 - 56 | This section defines parameters for the identity provider and should generally be left unchanged.  |
| 57 -73 | The `trusts` section is where you define which applications will trust this identity provdier.  This has the same options as a `Trust` object. |
| 70 - 73 | Each trust can provide a list of `secretParams` that references external `Secret` objects instead of local configuration. |
| 74 - 76 | The `results` section defines what happens in response to certain events.  Here, in response to the `auFail` and `azFail` events, the user is redirected to an invalid credentials page |
| 77 | The `uri` tells OpenUnison how to access this identity provider.  It will always follow the pattern `/auth/idp/appname`. |

Once your `Application` is deployed, you can test it without any kind of container restart.  Once you're tested, you can also [add a badge to the front page of your OpenUnison portal as well](#adding-a-badge-to-the-portal).

## Creating a SAML2 Identity Provider

## Using a Reverse Proxy Application

In addition to acting as an identity provider for applications that know how to authenticate via OpenID Connect and SAML2, OpenUnison can replace your oauth2 proxy for applications and integrate directly.  When integrating an application using OpenUnison's reverse proxy, the first step is to determine if your application can use your existing OpenUnison host name, or if it needs its own.  As an example, Prometheus can either run off the root of your host (`/`), or you can configure it to have a prefix URL such as `/prometheus`.  This section will walk through both scenarios.

### Using OpenUnison's Host

This is the easier of the two scenarios.  Similar to identity providers, Prometheus will be integrated using an `Application` object.  First, configure your Prometheus to use the correct external URL and prefix.  For instance, if your OpenUnison is configured to run on `openunison.domain.com` make sure your Promtheus `StatefulSet` has the following configureation parameters:

```yaml
- '--web.external-url=https://openunison.domain.com/prometheus'
- '--web.route-prefix=/prometheus/'
```

Next, create the below object in your cluster:

```yaml linenums="1"
---
apiVersion: openunison.tremolo.io/v2
kind: Application
metadata:
  name: prometheus
  namespace: openunison
spec:
  azTimeoutMillis: 3000
  isApp: true
  urls:
  - hosts:
    - "#[OU_HOST]"
    filterChain:
    - className: com.tremolosecurity.proxy.filters.XForward
      params:
        createHeaders: "true"
    - className: com.tremolosecurity.proxy.filters.HideCookie
      params: {}
    uri: "/prometheus"
    proxyTo: "http://prom-stack-kube-prometheus-prometheus.monitoring.svc:9090${fullURI}"
    authChain: login-service
    azRules:
    - scope: dn
      constraint: o=Tremolo
    results:
      azFail: default-login-failure
    overrideHost: true
    overrideReferer: true
    proxyConfiguration:
      connectionTimeoutMillis: 5000
      requestTimeoutMillis: 5000
      socketTimeoutMillis: 5000
  cookieConfig:
    sessionCookieName: tremolosession
    domain: "#[OU_HOST]"
    secure: true
    httpOnly: true
    logoutURI: "/logout"
    keyAlias: session-unison
```

Here is the details of this configuration:

| Lines | Description |
| ----- | ----------- |
| 1 - 7 | Standard kubernetes metadata |
| 8 | Determines how long authorization decisions should be cached.  Should generally not be changes and should only be as long as it typically takes a single action (such as an API or page load) to complete |
| 10 | Every `Application` in OpenUnison is made of multiple `url` entries.  Prometheus only requires a single url but this could be used for different urls in your application if needed |
| 11 - 12 | URLs need specific hosts to be associated with.  This is left unchanged in this use case |
| 13 | Applications can have a chain of filters that an act on headers and requested cookies as well as influence which cookies and headers are returned |
| 14 | The `XForward` filter injects the original host name as the `X-FORWARDED-FOR` header.  It will also set `X-FORWARDED-PROTO` |
| 17 | The 'HideCookies' filter will keep an application's own cookies in OpenUnison's internal session without ever sending them to the browser. |
| 19 | The `uri` tells OpenUnison how to access this application.  In this instance, any URLs that start with `/prometheus` will be forewarded to this `Application` | 
| 20 | This line tells OpenUnison where to forward requests to.  Add `${fullURI}` to get the originaly requested URI |
| 21 | The `auth-chain` is the name of an `AuthChain` object the URL will require for authentication.  In this use-case, do not change |
| 22 - 24 | Each URL can have its own authorization rules (`azRules`).  An authorization rule is made of a `scope` (one of `dn`,`group`,`filter`,`custom`) and a `constraint`, which defines what the rule is.  The combination of `dn` and `o=Tremolo` tells OpenUnison to authorize any user in the internal LDAP virtual directory.  If you wanted to only allow users in the group `cn=argocd-users,ou=Groups,DC=domain,DC=com` you would use `filter` as the `scope` and `(groups=cn=argocd-users,ou=Groups,DC=domain,DC=com)` as the `constraint` because OpenUnison internally represents groups in the Kubernetes integration as attributes instead of seperate objects. Multipls rules may be listed.  If ***ANY*** rule passes, the url is authorized |
| 25 - 26 | The `results` section defines what happens in response to certain events.  Here, in response to the `auFail` and `azFail` events, the user is redirected to an invalid credentials page |
| 27 | Tells OpenUnison to send the host defined in the requested URL in the `HOST` header, usually set to `true` |
| 28 | Tells OpenUnison to update the host in redirects to what is the requested URL, usually set to `true` |
| 29 - 32 | Provide OpenUnison with custom timeouts for your application.  Setting these timeouts will help if applications take too long to respond |
| 33 - 39 | Determines how the user's session cookie should be configured.  This section should generally be left unchanged when working with Kubernetes |

Once the `Application` object has been added to the `openunison` namespace, you can access Prometheus by going to `https://openunison.domain.com/prometheus`.  There's no need to create any new `Ingress` objects because you're re-using OpenUnison's own existing `Ingress`.  

Finallly, you'll want to [add a badge to your portal](#adding-a-badge-to-the-portal) so users can access Prometheus without having to memorize the URL.


### Using a New Host

If your application can't use OpenUnison's current host name, you can still configure OpenUnison to provide authentication and authorization for your application.  There are a couple of additional steps:

1. Define an `AuthChain` that trusts OpenUnison's kubernetes identity provider
2. Create an `Application` that references this new `AuthenticaionChain`
3. Create a `Trust` object that binds the `AuthChain` and the Kubernetes identity provider
4. Create an `Ingress` object

As an example, we'll configure a Prometheus instance that's running on its own host name - `prometheus.domain.com`.  The Promtheus `StatefulSet` has the following configureation parameters:

```yaml
- '--web.external-url=https://prometheus.domain.com/'
- '--web.route-prefix=/'
```

First, we'll define an `AuthChain`.  OpenUnison uses an `AuthChain` to create a sequence of `AuthMechs` to authenticate a user.  You generally won't need to worry aobut defining your own `AuthMech` objects.  Create this object in the `openunison` namespace:

```yaml linenums="1"
apiVersion: openunison.tremolo.io/v1
kind: AuthenticationChain
metadata:
  name: prometheus-oidc
  namespace: openunison
spec:
  authMechs:
  - name: oidc
    params:
      bearerTokenName: prometheus-ou
      clientid: prometheus
      defaultObjectClass: inetOrgPerson
      hd: ""
      idpURL: https://#[OU_HOST]/auth/idp/k8sIdp/auth
      jwtTokenAttributeName: id_token
      linkToDirectory: "true"
      loadTokenURL: https://#[OU_HOST]/auth/idp/k8sIdp/token
      lookupFilter: (sub=${sub})
      noMatchOU: oidc
      responseType: code
      scope: openid name offline
      uidAttr: sub
      userLookupClassName: com.tremolosecurity.unison.proxy.auth.openidconnect.loadUser.LoadJWTFromAccessToken
    required: required
    secretParams:
    - name: secretid
      secretKey: K8S_DB_SECRET
      secretName: orchestra-secrets-source
  level: 20
  root: o=Tremolo
```

Here are the details of the configuration:

| Lines | Description |
| ----- | ----------- |
| 1 - 5 | Standard kubernetes metadata |
| 7 - 28 | Defines each step in the chain referencing an `AuthMech` |
| 8 | The name of the `AuthMech` to use, in this case `oidc` |
| 10 | The name of the resulting `id_token` in a filter's request object |
| 11 | The `clientid` that will be defined in our `Trust` |
| 12 | If a user can't be found, the default objectClass, should not be changed |
| 13 | Only used with Google as an identity provider |
| 14 | The idp authorization URL |
| 15 | The attribute with the id_token in the response, do not change |
| 16 | Determines if OpenUnison should link the account with an internal directory object, keep `true` |
| 17 | The IdP's token URL, do not change |
| 18 - 23 | How OpenUnison should find the user, do not change |
| 24 | If the `AuthMech` is optional, do not change |
| 25 - 28 | List of parameters that will be pulled from a `Secret`.  Our configuration pulls the same `Secret` that was created for the dashboard trust |
| 29 | The authentication level, useful when you have multiple forms of authentication.  Do not change |
| 30 | The search root inside of OpenUnison's internal LDAP virtual directory, do not change |

Next, create the `Application` object:

```yaml linenums="1"
---
apiVersion: openunison.tremolo.io/v2
kind: Application
metadata:
  name: prometheus
  namespace: openunison
spec:
  azTimeoutMillis: 3000
  isApp: true
  urls:
  - hosts:
    - prometheus.domain.com
    filterChain:  
    - className: com.tremolosecurity.proxy.filters.XForward
      params:
        createHeaders: "true"
    - className: com.tremolosecurity.proxy.filters.HideCookie
      params: {}
    uri: "/"
    proxyTo: "http://prom-stack-kube-prometheus-prometheus.monitoring.svc:9090${fullURI}"
    authChain: prometheus-oidc
    azRules:
    - scope: dn
      constraint: o=Tremolo
    results:
      azFail: default-login-failure
    overrideHost: true
    overrideReferer: true
    proxyConfiguration:
      connectionTimeoutMillis: 5000
      requestTimeoutMillis: 5000
      socketTimeoutMillis: 5000
  cookieConfig:
    sessionCookieName: tremolosession
    domain: "prometheus.domain.com"
    secure: true
    httpOnly: true
    logoutURI: "/logout"
    keyAlias: session-unison
```

Here is the details of this configuration:

| Lines | Description |
| ----- | ----------- |
| 1 - 7 | Standard kubernetes metadata |
| 8 | Determines how long authorization decisions should be cached.  Should generally not be changes and should only be as long as it typically takes a single action (such as an API or page load) to complete |
| 10 | Every `Application` in OpenUnison is made of multiple `url` entries.  Prometheus only requires a single url but this could be used for different urls in your application if needed |
| 11 - 12 | URLs need specific hosts to be associated with.  This needs to be the host name you want to use to access your application|
| 13 | Applications can have a chain of filters that an act on headers and requested cookies as well as influence which cookies and headers are returned |
| 14 | The `XForward` filter injects the original host name as the `X-FORWARDED-FOR` header.  It will also set `X-FORWARDED-PROTO` |
| 17 | The 'HideCookies' filter will keep an application's own cookies in OpenUnison's internal session without ever sending them to the browser. |
| 19 | The `uri` tells OpenUnison how to access this application.  In this instance, any URLs that start with `/` will be forewarded to this `Application` | 
| 20 | This line tells OpenUnison where to forward requests to.  Add `${fullURI}` to get the originaly requested URI |
| 21 | The `auth-chain` is the name of an `AuthChain` object the URL will require for authentication.  In this use-case, use `prometheus-oidc` to reference the chain created above |
| 22 - 24 | Each URL can have its own authorization rules (`azRules`).  An authorization rule is made of a `scope` (one of `dn`,`group`,`filter`,`custom`) and a `constraint`, which defines what the rule is.  The combination of `dn` and `o=Tremolo` tells OpenUnison to authorize any user in the internal LDAP virtual directory.  If you wanted to only allow users in the group `cn=argocd-users,ou=Groups,DC=domain,DC=com` you would use `filter` as the `scope` and `(groups=cn=argocd-users,ou=Groups,DC=domain,DC=com)` as the `constraint` because OpenUnison internally represents groups in the Kubernetes integration as attributes instead of seperate objects. Multipls rules may be listed.  If ***ANY*** rule passes, the url is authorized |
| 25 - 26 | The `results` section defines what happens in response to certain events.  Here, in response to the `auFail` and `azFail` events, the user is redirected to an invalid credentials page |
| 27 | Tells OpenUnison to send the host defined in the requested URL in the `HOST` header, usually set to `true` |
| 28 | Tells OpenUnison to update the host in redirects to what is the requested URL, usually set to `true` |
| 29 - 32 | Provide OpenUnison with custom timeouts for your application.  Setting these timeouts will help if applications take too long to respond |
| 33 - 39 | Determines how the user's session cookie should be configured.  This section should generally be left unchanged when working with Kubernetes |

Next, create a `Trust`:

```yaml
apiVersion: openunison.tremolo.io/v1
kind: Trust
metadata:
  labels:
    app.kubernetes.io/name: openunison
    app.kubernetes.io/instance: openunison-orchestra
    app.kubernetes.io/component: prometheus
    app.kubernetes.io/part-of: openunison
  name: prometheus
  namespace: openunison
spec:
  accessTokenSkewMillis: 120000
  accessTokenTimeToLive: 60000
  authChainName: login-service
  clientId: prometheus
  clientSecret:
    keyName: K8S_DB_SECRET
    secretName: orchestra-secrets-source
  codeLastMileKeyName: lastmile-oidc
  codeTokenSkewMilis: 60000
  publicEndpoint: false
  redirectURI:
  - https://prometheus.domain.com/auth/oidc
  signedUserInfo: true
  verifyRedirect: true
```

Here are the details:

| Option | Desription |
| ------ | ---------- |
| accessTokenSkewMillis | Milliseconds milliseconds added to account for clock skew |
| accessTokenTimeToLive | Time an access token should live in milliseconds |
| authChainName | The authentication chain to use for login, do not change |
| clientId | The client id shared by your application | 
| clientSecret.scretName | If using a client secret, the name of the `Secret` storing the client secret |
| clientSecret.keyName | The key in the `data` section of the `Secret` storing the client secret |
| codeLastMileKeyName | The name of the key used to encrypt the code token, do not change |
| codeTokenSkewMilis | Milliseconds to add to code token lifetime to account for clock skew |
| publicEndpoint | If `true`, a client secret is required.  If `false`, no client secret is needed |
| redirectURI | List of URLs that are authorized for callback.  If a URL is provided by your application that isn't in this list SSO will fail |
| signedUserInfo | if `true`, the userinfo endpoint will return a signed JSON Web Token.  If `false` it will return plain JSON |
| verifyRedirect | If `true`, the redirect URL provided by the client **MUST** be listed in the `redirectURI` section.  Should **ALLWAYS** be `true` if not in a development environment |

Finally, create an `Ingress` object for your new application that reference's OpenUnison's `Service`.  The best option is to get the source for the `openunison-orchestra` object and customize it for your new application in a new `Ingress` object.  For instance, with an NGINX Ingress Controller:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    
    nginx.ingress.kubernetes.io/affinity: cookie
    nginx.ingress.kubernetes.io/backend-protocol: https
    nginx.ingress.kubernetes.io/secure-backends: "true"
    nginx.ingress.kubernetes.io/session-cookie-hash: sha1
    nginx.ingress.kubernetes.io/session-cookie-name: openunison-orchestra
    nginx.org/ssl-services: openunison-orchestra
  name: prometheus
  namespace: openunison
  
spec:
  rules:
  - host: prometheus.domain.com
    http:
      paths:
      - backend:
          service:
            name: openunison-orchestra
            port:
              number: 443
        path: /
        pathType: Prefix
  tls:
  - hosts:
    - prometheus.domain.com
    secretName: ou-tls-certificate
```

Once the `Ingress` object has been added to the `openunison` namespace, you can access Prometheus by going to `https://prometheus.domain.com/`. 

Finallly, you'll want to [add a badge to your portal](#adding-a-badge-to-the-portal) so users can access Prometheus without having to memorize the URL.

## Adding a "Badge" to the Portal

When you login to the Orchestra portal, there are badges for your tokens and for the dashboard.  You can dynamically add a badge for your application too.  Here's an example `PortalUrl` object for ArgoCD:

```yaml
apiVersion: openunison.tremolo.io/v1
kind: PortalUrl
metadata:
  name: argocd
  namespace: openunison
spec:
  label: ArgoCD
  org: B158BD40-0C1B-11E3-8FFD-0800200C9A66
  url: https://argocd.apps.192-168-2-140.nip.io
  icon: iVBORw0KGgoAAAANSUhEUgAAANIAAADwCAYAAAB1/Tp/AAAfQ3pUWHRSYXcgcHJvZ...
  azRules:
  - constraint: o=Tremolo
    scope: dn
```

| Option | Descriptoin |
| ------ | ----------- |
| label  | The label shown on badge in the portal |
| org    | If using orgnaizations to organize badges, the uuid of the org.  If not using organizations, leave as is |
| url    | The URL the badge should send the user to |
| icon   | A base64 encoded PNG with a width of 210 pixels and a height of 240 pixels |
| azRules | Who is authorized to see this badge?  See https://portal.apps.tremolo.io/docs/tremolosecurity-docs/1.0.19/openunison/openunison-manual.html#_applications_applications for an explination of the authorization rules |

Once created, the badge will appear in the Orchestra portal!  No need to restart the containers.